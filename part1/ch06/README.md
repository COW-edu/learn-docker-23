# 6장 도커 볼륨을 이용한 퍼시스턴트 스토리지

컨테이너는 무상태 애플리케이션에서는 최적의 실행환경임.  
사용량이 증가하더라도 클러스터에 실행중인 컨테이너 수를 늘리면 모든 요청이 똑같이 신뢰성 있게 처리됌. 롤링 업데이트를 통해 서비스 중단 없이 점진적 배포도 가능함.  
but 전혀 상태가 없을 수 없음. 퍼시스턴시나 성능 향상을 위해 디스크를 사용하는 컴포넌트 필요. 이역시 컨테이너에서 실행됌. -> 유상태 애플리케이션을 도커로 실행하려면 고려할게 많다.

도커 컨테이너에도 단일 드라이브로 된 filesystem 존재. ex) `COPY` 인스트럭션

도커 이미지는 여러개의 레이어 형태로 저장. 디스크도 마찬가지로 이미지 레이어를 순서대로 합쳐 만든 '가상 파일 시스템'

모든 컨테이너는 독립된 파일 시스템임. 같은 이미지에서 실행한 여러개의 컨테이너는 처음엔 디스크 내용이 모두 같지만, 한 컨테이너에서 파일을 수정해도 다른 컨테이너나 이미지에 영향 x.  
컨테이너는 종료해도 파일시스템은 삭제 x

컨테이너 파일 시스템은 단일 디스크다. 그러나 이 디스크는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템임. 이 출처는 기본적으로 이미지 레이어와 컨테이너의 기록 가능 레이어로 구성되는데, 이미지 레이어는 모든 컨테이너 공유하나 기록 가능 레이어는 컨테이너마다 다름.

- 이미지 레이어는 읽기 전용.
- 기록 가능 레이어는 컨테이너와 같은 생애주기를 가짐.
- 기록 가능 레이어는 기존 이미지 레이어에 있는 파일 수정 가능. (도커의 기록 중 복사 방법을 통해 읽기 전용 레이어 파일 수정 가능)

컨테이너에서 이미지 레이어에 포함된 파일 수정하기 -> 도커가 스토리지 효율적 사용 가능

1. 도커가 이 파일을 쓰기 가능 레이어로 복사
2. 쓰기 가능 레이어에서 파일 수정

예제

```docker
docker container run --name f1 diamol/ch06-file-display # input.txt 출력하는 컨테이너

echo "http://eltonstoneman.com" > url.txt

docker container cp url.txt f1:/input.txt

docker container start --attach f1
```

```docker
docker container run --name f2 diamol/ch06-file-display # input.txt 출력하는 컨테이너

docker container rm -f f1

docker container cp f1:/input.txt . # 컨테이너 삭제했으므로 파일 찾을 수 없음
```

컨테이너 파일 시스템은 컨테이너와 같은 생애주기를 가짐. -> 문제 발생 가능 (db를 파일로 저장한다든지..)  
컨테이너의 가상 파일 시스템은 이미지 레이어 + 기록 가능 레이어로 구성되지만 몇가지 추가 가능

1. 도커 볼륨
2. 마운트

도커 볼륨은 도커에서 스토리지를 다루는 단위임. 컨테이너를 위한 USB 메모리. 컨테이너와 독립적으로 존재하며 별도 생애주기를 갖지만 컨테이너에 연결 가능함.  
퍼시스턴시가 필요한 유상태 앱을 컨테이너로 실행하려면 볼륨을 사용해야 함. 볼륨을 생성해 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉토리가 되어 나중에 앱을 업데이트 해도 새 컨테이너에 다시 볼륨 연결 시 데이터 유지 가능

## 볼륨

볼륨 사용 방법

1. 수동으로 직접 볼륨 생성해 컨테이너에 연결
2. DockerFile 스크립트에서 VOLUME 인스트럭션 사용 (자동으로 볼륨 생성 됌.) `VOLUME <TARGET DIRECTORY>`

```docker
FROM diamol/dotnet-aspnet
WORKDIR /app
ENTRYPOINT ["dotnet", "app.dll"]

VOLUME /data
COPY --from=builder /out/ .
```

/data 디렉터리에는 다른 디렉터리와 똑같이 사용하지만 볼륨에 영구적으로 저장 됌.

```docker
docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list # dockerfile script의 정의에 볼륨 생성해 컨테이너 연결 스크립트가 있음.

docker container inspect --format '{{.Mounts}}' todo1 # mounts항목에서 볼륨정보 확인 가능

docker volume ls #볼륨은 도커에서 이미지 or 컨테이너와 동급 요소
```

도커 이미지에서 볼륨을 정의하면 컨테이너 생성할 때 마다 새로운 볼륨 생성.  
컨테이너가 같은 볼륨을 공유하게 하려면 `volumes-from` 플래그 적용 통해 다른 컨테이너의 볼륨 연결 가능

```docker
docker container run --name todo2 -d diamol/ch06-todo-list

docker container exec todo2 ls /data

docker container run -d --name todo3 --volumes-from todo1 diamol/ch06-todo-list

docker container exec t3 ls /data
```

1번, 3번 컨테이너는 볼륨 공유하는걸 확인 가능.

도커 볼륨은 컨테이너 간 파일 공유보단 업데이트 간 상태를 보존하기 위한 용도로 사용해야됌. 이미지 정의하는거 보단 명시적으로 관리하는게 나음.  
볼륨에 이름을 붙여 생성하고 업데이트 시 다른 컨테이너로 옮기는 식.

dockerfile script의 `VOLUME` 인스트럭션과 docker container 명령의 `--volume` 플래그는 별개 기능임.
`VOLUME` 인스트럭션을 사용해 빌드된 이미지로 docker container run 명령에서 볼륨 지정 안하면 항상 새로 볼륨이 생성됌. 컨테이너 삭제 후 볼륨 재사용할 시 식별자 기억해야됌.  
`--volume` 플래그는 이미지에 볼륨이 정의돼든 말든 지정된 볼륨을 마운트함. 이미지에 볼륨이 정의되도 정의가 무시됌. 생성자 -> `VOLUME` 인스트럭션 추가. 사용자 -> `--volume` 통해 명시

## 마운트

볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서 도커 사용하는 방식 그대로 스토리지 다룰 수 있음.
볼륨은 호스트 컴퓨터 상에 존재하지만 컨테이너와는 분리됌. 하지만 호스트 스토리지를 컨테이너에 직접적으로 연결할 수 있는 수단이 <b>바운드 마운트</b>임.

바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만듬. 컨테이너 입장에선 평범한 디렉터리에 불과. 하지만 서로간 직접 접근 가능. 양방향.

```docker
source = "$(pwd)/databses" && target='/data' #경로 환경변수 지정

mkdir ./databases

docker container run --mount type=bind, source=$source, target=$target -d -p 8012:80
diamol/ch06-todo-list

curl http://localhost:8012

ls ./databases
```

양방향으로 파일 접근 가능 -> Dockerfile 스크립트에서 USER 인스트럭션 통해 컨테이너에 관리자 권한 부여 가능. 호스트 컴퓨터 디렉터리에 읽기 전용으로 연결도 가능.

한계점.

1. 컨테이너의 마운트 대상 디렉토리가 이미 존재하고 이미지 레이어에 이 디렉토리 파일이 포함되면 마운트의 원본 디렉토리가 기존 디렉토리를 완전히 대체 함. -> 이미지 포함된 파일 사용 불가
2. 호스트에 위치한 파일을 컨테이너에 이미 존재하는 디렉터리로 마운트 시 문제 발생가능. 호스트 운영체제 별로 파일 위치명이 달라지기 때문
3. 분산 파일시스템을 컨테이너에 마운트 시 지원하지 않는 동작이 있을 수 있음.

모든 컨테이너는 도커가 다양한 출처로 부터 모아 만든 단일 가상 디스크로 구성된 파일시스템을 가짐. `유니언 파일 시스템`이라 함. but 운영체제 마다 다른 방식으로 구현됌.

컨테이너는 유니언파일시스템을 통해 단일 디스크를 사용하듯 접근 가능. 애플리케이션 입장에선 단일 디스크만 볼 수 있지만, 컨테이너나 이미지를 생성해 사용하는 사용자는 여러 출처를 합쳐 디스크를 구성 가능함.

여러개 이미지 레이어, 여러개 볼륨 마운트와 바인드 마운트를 컨테이너 연결 가능. But, 기록 가능 레이어는 하나만 가져야함.

## 컨테이너 스토리지 구성 시 고려해야 할 일반론

기록 가능 레이어: 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터의 캐싱 등 단기 저장에 적합하다. 각 컨테이너마다 독립적인 기록 가능 레이어를 갖지만, 컨테이너가 삭제되면 여기 저장된 데이터는 유실된다.

로컬 바인드 마운트: 호스트 컴퓨터와 컨테이너 간 데이터를 공유하기 위해 사용한다. 개발자의 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달하기 위해 사용하면 로컬 컴퓨터에서 수정한 내용이 이미지 빌드 없이도 즉시 컨테이너로 전달 될 수 있다.

분산 바인드 마운트: 네트워크 스토리지와 컨테이너 간에 데이터를 공유하기 위해 사용한다.
가용성이 높지만 로컬 디스크와 비교해 지원하지 않는 파일 시스템 기능이 있거나 성능 면에서 차이가 있을 수 있다.
읽기 전용으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있으며 읽기 쓰기 가능으로 데이터를 저장해 동일 네트워크 상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는 데 적합하다.

볼륨 마운트: 컨테이너와 도커 객체인 볼륨 간에 데이터를 공유하기 위해 사용된다. 볼륨 마운트를 사용하면 애플리케이션이 볼륨에 데이터를 영구적으로 저장한다. 컨테이너를 교체하는 방식으로 애플리케이션을 업데이트해도, 이전 버전 컨테이너의 데이터를 그대로 유지할 수 있다.

이미지 레이어: 이미지 레이어는 컨테이너의 초기 파일 시스템을 구성한다. 레이어는 적층 구조를 갖는데, 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우 후속 레이어의 내용이 적용된다. 레이어는 읽기 전용이며 여러 컨테이너가 공유한다.
